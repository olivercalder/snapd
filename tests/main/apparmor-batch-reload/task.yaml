summary: Ensure that batch-reloading of AppArmor profiles works, including fallback

systems: [ubuntu-1*]

environment:
    VARIANT/changed: changed
    VARIANT/unchanged: unchanged
    AA_CACHE: /var/cache/apparmor/
    AA_PROFILES: /var/lib/snapd/apparmor/profiles/

prepare: |
    snap install test-snapd-content-plug test-snapd-tools
    snap install --edge test-snapd-curl
    cp /sbin/apparmor_parser /sbin/apparmor_parser.real
    rm -f /tmp/apparmor-parser-calls.debug

restore: |
    mv /sbin/apparmor_parser.real /sbin/apparmor_parser
    rm -f /tmp/apparmor-parser-calls.debug profiles.out

debug: |
    cat /tmp/apparmor-parser-calls.debug || true

execute: |
    systemctl stop snapd.{service,socket}

    echo "Update system key"
    printf '{"version":1}' > /var/lib/snapd/system-key

    # this makes is easier to analyse the sequence of events shall something fail
    echo "system key update" >> /tmp/apparmor-parser-calls.debug

    echo "Replace apparmor parser with a broken one"
    cp -f bin/apparmor_parser.fake /sbin/apparmor_parser

    # remove all apparmor cached profiles so we can check they are recreated
    rm -f $AA_CACHE/snap* $AA_CACHE/*/snap*

    # "changed" variant requires source profiles on the disk to look different than the
    # ones generated on snapd restart, simulate this by appending a comment to them.
    if [ "$VARIANT" = "changed" ]; then
        for profile in "$AA_PROFILES"/snap*; do
            echo "# forced profile change" >> "$profile"
        done
    fi
    systemctl start snapd.{socket,service}

    echo "Checking that apparmor profile cache has been populated"
    # note, the list is not exhaustive but is enough for the test and the journal check below
    expected_profiles=$(cat <<EOF
    snap-update-ns.test-snapd-content-plug
    snap-update-ns.test-snapd-curl
    snap-update-ns.test-snapd-tools
    snap.test-snapd-content-plug.content-plug
    snap.test-snapd-curl.curl
    snap.test-snapd-tools.block
    snap.test-snapd-tools.cat
    snap.test-snapd-tools.cmd
    snap.test-snapd-tools.echo
    snap.test-snapd-tools.env
    snap.test-snapd-tools.fail
    snap.test-snapd-tools.head
    snap.test-snapd-tools.sh
    snap.test-snapd-tools.success
    EOF
    )

    retry=50
    while true; do
        if [ $retry -le 0 ]; then
            echo "Expected AppArmor profiles not found in the cache directory."
            echo "Expected: $expected_profiles; Got:"
            cat profiles.out
            exit 1
        fi
        # apparmor cache is a forest on newer Ubuntu (e.g. 19.10), therefore use find
        find $AA_CACHE/ -name '*test-snapd*' -exec basename {} \; | sort > profiles.out
        echo "$expected_profiles" | diff profiles.out - && break
        sleep 1
        retry=$(( retry - 1 ))
    done

    #shellcheck source=tests/lib/journalctl.sh
    . "$TESTSLIB"/journalctl.sh

    echo "Check log notification about failed batch-reload"
    # grep by "fail" to reduce log/debug noise in case of a match failure below
    log="$(get_journalctl_log -a -u snapd|grep -i fail)"
    echo "$log" | MATCH "failed to batch-reload $VARIANT profiles: cannot load apparmor profiles"
    # we're matching a single long log line with non-deterministic order of profiles, therefore it's split
    echo "$log" | MATCH "FAIL ON: .*/snap-update-ns.test-snapd-curl"
    echo "$log" | MATCH "FAIL ON: .*/snap.test-snapd-curl.curl"
    echo "$log" | MATCH "FAIL ON: .*/snap-update-ns.test-snapd-tools"
    echo "$log" | MATCH "FAIL ON: .*/snap.test-snapd-tools.block"
    echo "$log" | MATCH "FAIL ON: .*/snap.test-snapd-tools.cat"
