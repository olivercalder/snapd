summary: Ensure installer APIs works on unencrypted devices

# needs a modern ubuntu
systems: [ubuntu-20.04-64, ubuntu-22.04-64]

environment:
  STORE_ADDR: localhost:11028
  STORE_DIR: $(pwd)/fake-store-blobdir

prepare: |
  if [ "$TRUST_TEST_KEYS" = "false" ]; then
      echo "This test needs test keys to be trusted"
      exit
  fi

  echo "Install used snaps"
  snap install test-snapd-curl --devmode --edge
  snap install jq --devmode --edge

  if [ -d /var/lib/snapd/seed ]; then
      mv /var/lib/snapd/seed /var/lib/snapd/seed.orig
  fi
   #shellcheck source=tests/lib/store.sh
   . "$TESTSLIB"/store.sh
   setup_fake_store "$STORE_DIR"

restore: |
  if [ "$TRUST_TEST_KEYS" = "false" ]; then
      echo "This test needs test keys to be trusted"
      exit
  fi

  rm -rf /var/lib/snapd/seed
  if [ -d /var/lib/snapd/seed.orig ]; then
      mv /var/lib/snapd/seed.orig /var/lib/snapd/seed
  fi
  #shellcheck source=tests/lib/store.sh
  . "$TESTSLIB"/store.sh
  teardown_fake_store "$STORE_DIR"
  rm -rf ./classic-root

execute: |
  if [ "$TRUST_TEST_KEYS" = "false" ]; then
      echo "This test needs test keys to be trusted"
      exit
  fi

  # XXX: the code in DeviceManager.SystemAndGadgetInfo() will only work on
  # classic systems with modeenv right now (which is something we may need
  # to fix to work from the classic installer).
  # For now pretend we have a modeenv
  echo "mode=run" > /var/lib/snapd/modeenv
  tests.cleanup defer rm -f /var/lib/snapd/modeenv
  # need snapd restart as GET /systems/<label> is only available on systems
  # with a modeenv
  systemctl restart snapd

  echo Expose the needed assertions through the fakestore
  cp "$TESTSLIB"/assertions/developer1.account "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/developer1.account-key "$STORE_DIR/asserts"
  cp "$TESTSLIB"/assertions/testrootorg-store.account-key "$STORE_DIR/asserts" 
  export SNAPPY_FORCE_SAS_URL=http://$STORE_ADDR

  # prepare a classic seed
  # TODO:
  # - create pc-classic custom gadget
  # - kernel with updated initrd
  # - repacked snapd snap
  # (should be as simple as addinga "--snap=./local-gadget.snap ...")
  LABEL="$(date +%Y%m%d)"
  gendeveloper1 sign-model < "$TESTSLIB"/assertions/developer1-22-classic-dangerous.json > my.model
  snap prepare-image --classic --channel=edge my.model ./classic-seed
  cp -a ./classic-seed/system-seed/ /var/lib/snapd/seed

  # do some light checking that the system is valid
  test-snapd-curl.curl -s --unix-socket /run/snapd.socket http://localhost/v2/systems | jq '.result.systems[0].label' | MATCH "$LABEL"
  test-snapd-curl.curl -s --unix-socket /run/snapd.socket http://localhost/v2/systems/"$LABEL" > system
  jq '.result.model.distribution' system | MATCH "ubuntu"
  
  # build fakeinstaller and put in place
  go build -o fakeinstaller "$TESTSLIB"/fakeinstaller/main.go

  # create fake disk for the installer to work on
  truncate --size=4G fake-disk.img
  loop_device=$(losetup --show -f ./fake-disk.img)
  echo "label: gpt" | sfdisk "$loop_device"
  # and "install" the current seed to the fake disk
  ./fakeinstaller "$LABEL" "$loop_device" "$TESTSLIB"/fakeinstaller/mk-classic-rootfs.sh
  # validate that the fake installer created the expected partitions
  fdisk -x "$loop_device" > fdisk_output
  MATCH "${loop_device}p1 .* BIOS Boot"   < fdisk_output
  # TODO: the real MVP hybrid device will not contain a ubuntu-seed
  #       partition (needs a different gadget)
  MATCH "${loop_device}p2 .* ubuntu-seed" < fdisk_output
  MATCH "${loop_device}p3 .* ubuntu-boot" < fdisk_output
  MATCH "${loop_device}p4 .* ubuntu-save" < fdisk_output
  MATCH "${loop_device}p5 .* ubuntu-data" < fdisk_output

  # image partitions are mounted by the installer (should they be?)
  for d in ubuntu-seed ubuntu-boot ubuntu-data ubuntu-save; do
      test -d /run/mnt/"$d"
      mountpoint /run/mnt/"$d"
  done
  # seed is populated
  test -d /run/mnt/ubuntu-data/var/lib/snapd/seed/systems/"$LABEL"
  # rootfs is there
  test -x /run/mnt/ubuntu-data/usr/lib/systemd/systemd
  # ensure not "ubuntu-data/system-data" is generated, this is a dir only
  # used on core and should not be there on classic
  not test -d /run/mnt/ubuntu-data/system-data
  # and the boot assets are in the right place
  test -e /run/mnt/ubuntu-boot/EFI/ubuntu/kernel.efi
  test -e /run/mnt/ubuntu-boot/EFI/ubuntu/grubenv
  test -e /run/mnt/ubuntu-boot/EFI/boot/grubx64.efi
  # and we have a modenv in the image
  MATCH "mode=run" < /run/mnt/ubuntu-data/var/lib/snapd/modeenv
  MATCH "recovery_system=$LABEL" < /run/mnt/ubuntu-data/var/lib/snapd/modeenv
  MATCH "classic=true" < /run/mnt/ubuntu-data/var/lib/snapd/modeenv
