summary: the boot base provides essential fsck programs
# TODO:UC20: this test really fails on core20, fsck is not invoked!
systems: [-ubuntu-core-20-64]
details: |
  Snapd uses vfat on certain essential boot partitions, due to external
  requirements imposed by the bootloader architecture. This test verifies that
  the boot process is capable of detecting unclean fvat and fixing it before
  such file system is mounted. This is an essential property to ensure
  longevity of devices that rely on write to vfat to operate.
prepare: |
  tests.cleanup prepare
execute: |
  echo "We can corrupt the boot partition"
  # FAT uses a specific byte to effectively indicate that the file system is
  # dirty. The precise details as to how this byte is used by each system vary,
  # but Linux sets it on a non-read-only mount, and clears it on unmount. We
  # can set it manually, verify it when the image is mounted and observe fsck
  # clearing it. Note that larger block devices use FAT32 and the offset
  # differs. FAT12 and FAT16 uses 37 while FAT32 uses 65.
  printf "\x01" > one
  tests.cleanup defer rm -f one

  cat /proc/self/mountinfo > mount.log

  if [ "$SPREAD_REBOOT" -eq 0 ]; then
    case "$SPREAD_SYSTEM" in
      ubuntu-core-16-*)
        # Refer to the core 16 PC gadget for details:
        # https://github.com/snapcore/pc-amd64-gadget/blob/16/gadget.yaml
        umount /boot/efi
        # Use offset 65 as FAT32 kicks in for devices larger than 32MB
        dd if=one of=/dev/sda2 seek=65 bs=1 count=1 conv=notrunc
        ;;
      ubuntu-core-18-*)
        # Refer to the core 18 PC gadget for details:
        # https://github.com/snapcore/pc-amd64-gadget/blob/18/gadget.yaml
        umount /boot/efi
        umount /boot/grub
        # Use offset 65 as FAT32 kicks in for devices larger than 32MB
        dd if=one of=/dev/sda2 seek=65 bs=1 count=1 conv=notrunc
        ;;
      ubuntu-core-20-*)
        # TODO:UC20 The property of having to keep a mounted vfat at all time
        # is not the most fortunate. Any power loss will result in a dirty
        # filesystem. Could ubuntu-seed be re-mounted read-only at some point
        # during the start-up process?  Power loss on read-only vfat is
        # harmless in comparison.
        umount /run/mnt/ubuntu-seed/systems/*/snaps/snapd_*.snap
        umount /var/lib/snapd/seed
        umount /run/mnt/ubuntu-seed
        # Use offset 65 as FAT32 kicks in for devices larger than 32MB
        dd if=one of=/dev/sda2 seek=65 bs=1 count=1 conv=notrunc
        ;;
      *)
        echo "Please adjust the test to support this core system"
        false
        ;;
    esac
    REBOOT
  fi

  # Note that we cannot read the dirty byte from the filesystem as it is
  # automatically set by the kernel when vfat is mounted. We must resort
  # to observing the kernel ring buffer. Should this message ever change, the
  # sister fsck-vfat test does a controlled experiment in mounting a dirty
  # vfat, to ensure that we are aware of such changes.
  echo "On the next boot, we should not see the dirty flag anymore"
  dmesg -c > dmesg-on-boot.log
  not MATCH "Volume was not properly unmounted. Some data may be corrupt. Please run fsck." < dmesg-on-boot.log
restore: |
  tests.cleanup restore
  rm -f ./*.log
