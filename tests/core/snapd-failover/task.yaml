summary: Check that snapd failure handling works

# TODO:UC20: enable for UC20, currently snapd.failure.service does not work on
#            UC20, it currently isn't activated for some reason
systems: [-ubuntu-core-20-*]

debug: |
    # shellcheck source=tests/lib/systems.sh
    . "$TESTSLIB/systems.sh"
    # dump failure data
    journalctl -u snapd.failure.service
    journalctl -u snapd.socket || true
    if is_core16_system; then
        ls -l /snap/core/
    fi
    ls -l /snap/snapd/

    cat /etc/systemd/system/snapd.service
    cat /etc/systemd/system/usr-lib-snapd.mount
    /snap/snapd/x1/usr/bin/snap debug state /var/lib/snapd/state.json || true
    /snap/snapd/x1/usr/bin/snap debug state --change="$(snap debug state /var/lib/snapd/state.json|tail -n1|awk '{print $1}')" /var/lib/snapd/state.json || true


execute: |
    # shellcheck source=tests/lib/journalctl.sh
    . "$TESTSLIB/journalctl.sh"

    # shellcheck source=tests/lib/systems.sh
    . "$TESTSLIB/systems.sh"

    echo "Testing failover handling of the snapd snap"

    # for debugging
    snap list --all

    # get the number of times that snapd.failure was started before we do 
    # anything
    started_before="$(get_journalctl_log -u snapd.failure | grep -c 'Started Failure handling of the snapd snap.' || true)"

    # only test that random signals don't trigger snapd-failure on UC18+, 
    # because snapd.failure does not exist on UC16 by default so there's nothing
    # to test with this on UC16
    if ! is_core16_system; then
        current=$(readlink /snap/snapd/current)

        echo "Verify that a random signal does not trigger the failure handling"
        echo "and snapd is just restarted"
        systemctl kill --signal=SIGSEGV snapd.service

        started_after_rand_sig="$(get_journalctl_log -u snapd.failure | grep -c 'Started Failure handling of the snapd snap.' || true)"

        if [ "$started_after_rand_sig" -gt "$started_before" ] ; then
            echo "snapd.failure inadvertently started with a random signal!"
            exit 1
        fi

        echo "Snap list is working still"
        snap list | MATCH "^snapd .* $current .*"

        SNAPD_SNAP=$(ls /var/lib/snapd/snaps/snapd_"$current".snap)
    else
        # this will be used for uc16 tests a bit later
        current=$(readlink /snap/core/current)

        snap download snapd --basename=snapd
        SNAPD_SNAP=$(pwd)/snapd.snap
    fi


    echo "Break snapd"
    unsquashfs -d ./snapd-broken "$SNAPD_SNAP"
    echo "" > ./snapd-broken/usr/lib/snapd/snapd

    if is_core16_system; then
        # pick up snap-failure from the current core snap as that's where the 
        # updated code under test is located
        cp -a /usr/lib/snapd/snap-failure ./snapd-broken/usr/lib/snapd/snap-failure
    fi

    (cd ./snapd-broken && snap pack .)
    echo "Now install the broken snapd"
    if snap install --dangerous ./snapd-broken/snapd_*.snap; then
        echo "installing a broken snapd should not work, test broken"
        exit 1
    fi

    echo "Verify that snapd.failure was activated when we tried to install a broken snapd"
    for _ in $(seq 60); do
        # get the number of times that snapd.failure was started
        started_after="$(get_journalctl_log -u snapd.failure | grep -c 'Started Failure handling of the snapd snap.' || true)"
        if [ "$started_after" -gt "$started_before" ] ; then
            break
        fi
        sleep 1
    done

    # just because snapd.failure.service is active doesn't mean that we are 
    # fully ready; we should wait until the snap command shows up again
    echo "And verify that snap commands still work and snapd is reverted"
    echo "Verify that we were rolled back to the previous snapd"
    if is_core16_system; then
        retry-tool -n 30 --wait 1 bash -c 'snap list | MATCH "^core .* $current .*"'
    else
        retry-tool -n 30 --wait 1 bash -c 'snap list | MATCH "^snapd .* $current .*"'
    fi

    echo "Verify we got the expected error message"
    snap change --last=install|MATCH "there was a snapd rollback across the restart"

    echo "restart snapd and ensure we can still talk to it"
    systemctl restart snapd.socket snapd.service

    if is_core16_system; then
        # on UC16 we should have rolled back to the core snap, and there should
        # be no snapd snap left installed
        snap list | MATCH "^core .* $current .*"

        echo "No snapd snap is installed"
        not snap list snapd

        test ! -e /etc/systemd/system/snapd.service
        test ! -e /etc/systemd/system/usr-lib-snapd.mount
        test ! -e /snap/snapd/x1
    else
        # on UC18+ we should still have the snapd snap and it should have the 
        # revision we had before the broken one was installed
        snap list | MATCH "^snapd .* $current .*"
    fi
