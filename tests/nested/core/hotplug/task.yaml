summary: Create ubuntu classic image, install snapd and test hotplug feature

prepare: |
    #shellcheck source=tests/lib/nested.sh
    . "$TESTSLIB/nested.sh"
    create_nested_core_vm

    snap pack "$TESTSLIB"/snaps/serial-port-hotplug
    copy_remote serial-port-hotplug_1.0_all.snap

    if is_core_18_nested_system; then
        execute_remote "sudo snap install --devmode jq-core18"
        execute_remote "sudo snap alias jq-core18.jq jq"
    else
        execute_remote "sudo snap install --devmode jq"
    fi

restore: |
    #shellcheck source=tests/lib/nested.sh
    . "$TESTSLIB/nested.sh"
    destroy_nested_vm
    rm -f /tmp/serialport{0,1}

debug: |
    #shellcheck source=tests/lib/nested.sh
    . "$TESTSLIB/nested.sh"

    set +e
    execute_remote "snap connections --all"
    execute_remote "snap list"
    execute_remote "dmesg"
    execute_remote 'sudo jq -r ".data[\"hotplug-slots\"]" /var/lib/snapd/state.json'

execute: |
    hotplug_add_dev1() {
        add_tty_chardev my-chardev1 /tmp/serialport1
        add_usb_serial_device my-usb-serial my-chardev1 1234
    }

    hotplug_del_dev1() {
        del_device my-usb-serial
        remove_chardev my-chardev1
    }

    hotplug_add_dev2() {
        add_tty_chardev my-chardev2 /tmp/serialport2
        add_usb_serial_device my-usb-serial2 my-chardev2 5678
    }

    hotplug_del_dev2() {
        del_device my-usb-serial2
        remove_chardev my-chardev2
    }

    # Check that given slot is not present in 'snap connections' output
    # (note, it can still be present in the state with hotplug-gone=true)
    check_slot_not_present() {
        SLOT_NAME="$1"
        for _ in $(seq 10); do
            if ! execute_remote "snap connections system" | MATCH ":$SLOT_NAME"; then
                break
            fi
            sleep 1
        done
        if execute_remote "snap connections system" | MATCH ":$SLOT_NAME "; then
            echo "slot $SLOT_NAME shouldn't be present anymore"
            exit 1
        fi
    }

    # Check that given slot is present in 'snap connections' output (but is not connected)
    check_slot_present() {
        SLOT_NAME="$1"
        for _ in $(seq 10); do
            if execute_remote "snap connections system" | MATCH "serial-port .* - .* :$SLOT_NAME"; then
                break
            fi
            sleep 1
        done
        execute_remote "snap connections system" | MATCH "serial-port .* - .* :$SLOT_NAME"
    }

    # Check that given slot has hotplug-gone=true, meaning the device was unplugged but there are connections remembered for it
    check_slot_gone() {
        SLOT_NAME="$1"
        execute_remote 'sudo jq -r ".data[\"hotplug-slots\"][\"'"$SLOT_NAME"'\"][\"hotplug-gone\"]" /var/lib/snapd/state.json' | MATCH "true"
    }

    # Check that given slot has hotplug-gone=false, meaning the device is plugged
    check_slot_not_gone() {
        SLOT_NAME="$1"
        execute_remote 'sudo jq -r ".data[\"hotplug-slots\"][\"'"$SLOT_NAME"'\"][\"hotplug-gone\"]" /var/lib/snapd/state.json' | MATCH "false"
    }

    # Check that given slot has no record in "hotplug-slots" map in the state
    check_slot_not_present_in_state() {
        SLOT_NAME="$1"
        execute_remote 'sudo jq -r ".data[\"hotplug-slots\"][\"'"$SLOT_NAME"'\"] // \"missing\"" /var/lib/snapd/state.json' | MATCH "missing"
    }

    check_slot_device_path() {
        SLOT_NAME="$1"
        DEVICE_PATH="$2"
        execute_remote 'sudo jq -r ".data[\"hotplug-slots\"][\"'"$SLOT_NAME"'\"][\"static-attrs\"].path" /var/lib/snapd/state.json' | MATCH "$DEVICE_PATH"
    }

    # Check that given slot is connected to the serial-port-hotplug snap, per 'snap connections' output
    check_slot_connected() {
        SLOT_NAME="$1"
        for _ in $(seq 10); do
            if execute_remote "snap connections" | MATCH "serial-port .*serial-port-hotplug:serial-port .*$SLOT_NAME"; then
                break
            fi
            sleep 1
        done
        execute_remote "snap connections" | MATCH "serial-port .*serial-port-hotplug:serial-port .*$SLOT_NAME"
    }

    # Check that apparmor profile allows rw access to given device path.
    verify_apparmor_profile() {
        DEVPATH=$1
        for _ in $(seq 10); do
            if execute_remote "cat /var/lib/snapd/apparmor/profiles/snap.serial-port-hotplug.consumer" | MATCH "$DEVPATH rw,"; then
                break
            fi
            sleep 1
        done
        execute_remote "cat /var/lib/snapd/apparmor/profiles/snap.serial-port-hotplug.consumer" | MATCH "$DEVPATH rw,"
    }

    wait_for_all_changes() {
        for _ in $(seq 10); do
            if ! execute_remote "snap changes" | MATCH "Doing"; then
                break
            fi
            sleep 1
        done
    }

    #shellcheck source=tests/lib/nested.sh
    . "$TESTSLIB/nested.sh"

    if [ "$NEW_CORE_CHANNEL" = "" ]; then
        echo "please set the SPREAD_NEW_CORE_CHANNEL environment"
        exit 1
    else
        echo "Refreshing the core snap"
        if is_core_18_nested_system; then
            execute_remote "snap refresh core18 --${NEW_CORE_CHANNEL}"
        else
            execute_remote "snap refresh core --${NEW_CORE_CHANNEL}"
        fi
        wait_for_no_ssh
        wait_for_ssh
    fi

    if execute_remote "udevadm info -e" | MATCH "ID_MODEL=QEMU_USB_SERIAL"; then
        echo "USB serial already registered, exiting..."
        exit 1
    fi

    execute_remote "sudo snap install hello-world"

    echo "Enabling hotplug"
    execute_remote "sudo snap set core experimental.hotplug=true"

    echo "Plugging the device"
    hotplug_add_dev1

    # sanity checks to make sure qemu setup is correct
    for _ in $(seq 5); do
        if execute_remote "udevadm info -e" | MATCH "ID_MODEL=QEMU_USB_SERIAL"; then
            break
        fi
        sleep 1
    done

    execute_remote "ls /dev/tty*" | MATCH "ttyUSB0"

    echo "Checking that qemuusbserial hotplug slot is present"
    check_slot_present qemuusbserial
    check_slot_not_gone qemuusbserial
    check_slot_device_path qemuusbserial "/dev/ttyUSB0"

    echo "Unplugging the device with no connections on the slot"
    hotplug_del_dev1

    # sanity check to make sure qemu event was triggered correctly
    for _ in $(seq 5); do
        if execute_remote "udevadm info -e" | MATCH "ID_MODEL=QEMU_USB_SERIAL"; then
            sleep 1
        else
            break
        fi
    done
    if execute_remote "udevadm info -e" | MATCH "ID_MODEL=QEMU_USB_SERIAL"; then
        echo "USB serial should not be registered anymore, exiting..."
        exit 1
    fi

    echo "Checking that hotplug slot is no longer present"
    check_slot_not_present qemuusbserial
    check_slot_not_present_in_state qemuusbserial

    echo "Checking that qemuusbserial hotplug slot is not present, but is still remembered"
    check_slot_not_present qemuusbserial
    check_slot_gone qemuusbserial

    echo "Hotplug slot stays after removing the snap"
    execute_remote "sudo snap remove serial-port-hotplug"
    check_slot_present qemuusbserial
    check_slot_not_gone qemuusbserial
