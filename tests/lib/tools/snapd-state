#!/bin/bash -e

show_help() {
    echo "usage: check-state <jq-filter> <comparison> <expected-res> <error-message>"
    echo "       print-state <jq-filter>"
    echo "       change-snap-channel <snap-name> <channel>"
    echo "       force-autorefresh"
    echo "       prevent-autorefresh"
    echo "       wait-for-autorefresh <last-change-id>"
    echo ""
    echo "The tool is used to manage the snapd state by editing the state.json file."
    echo "Also it is used to check state and refresh status"
}

print_state() {
    JQ_FILTER=$1
    if [ -z "$JQ_FILTER" ]; then
        echo "snapd-state: jq filter is needed"
        exit 1
    fi
    # we are storing jq filter specs in JQFILTER, so we can't use --arg like 
    # normal with jq, so instead just do a _real_ simple and potentially 
    # _really_ annoying string concatenation with the actual verbatim variable
    jq -r "$JQ_FILTER" < /var/lib/snapd/state.json
}

check_state() {
    JQ_FILTER=$1
    COMP=$2
    RES=$3
    FAIL_MSG="${4:-failed values comparison}"
    if [ "$COMP" = "!=" ]; then
        if [ "$(print_state \"$JQ_FILTER\")" != "$RES" ]; then
            echo "snapd-state: $FAIL_MSG"
            exit 1
        fi
    elif [ "$COMP" = "=" ]; then
        if [ "$(print_state \"$JQ_FILTER\")" = "$RES" ]; then
            echo "snapd-state: $FAIL_MSG"
            exit 1
        fi
    else
        echo "snapd-state: invalid comparison operator: $COMP"
        exit 1
    fi
}

change_snap_channel() {
    local SNAP="$1"
    local CHANNEL="$2"
    jq ".data.snaps[\"$SNAP\"].channel = \"$CHANNEL\"" /var/lib/snapd/state.json > /var/lib/snapd/state.json.new
    mv /var/lib/snapd/state.json.new /var/lib/snapd/state.json
}

force_autorefresh() {
    jq ".data[\"last-refresh\"] = \"2007-08-22T09:30:44.449455783+01:00\"" /var/lib/snapd/state.json > /var/lib/snapd/state.json.new
    mv /var/lib/snapd/state.json.new /var/lib/snapd/state.json
}

prevent_autorefresh() {
    jq ".data[\"last-refresh\"] = \"$(date +%Y-%m-%dT%H:%M:%S%:z)\"" /var/lib/snapd/state.json > /var/lib/snapd/state.json.new
    mv /var/lib/snapd/state.json.new /var/lib/snapd/state.json
}

wait_for_autorefresh() {
    local SNAP="$1"
    local LAST_CHANGE_ID="${2:-1}"
    local CHANGE_ID
    CHANGE_ID="$LAST_CHANGE_ID"

    if [ -z "$SNAP" ]; then
        echo "snapd-state: snap needed waiting for an autorefresh"
        exit 1
    fi
    for _ in $(seq 200); do
      # get last 2 lines of snap changes (the last one is always empty), match
      # auto-refresh change; only proceed if the change has greater change id
      # than the previously matched auto-refresh (this way we can match
      # consecutive auto-refreshes).
      if CHANGES=$(snap changes | tail -2 | grep "Done.*Auto-refresh.*$SNAP"); then
        CHANGE_ID=$(echo "$CHANGES" | awk '{print $1}')
        if [ "$CHANGE_ID" -gt "$LAST_CHANGE_ID" ]; then
          break
        fi
      fi
      snap debug ensure-state-soon
      sleep 1
    done
    if [ "$LAST_CHANGE_ID" -eq "$CHANGE_ID" ]; then
      echo "snapd-state: expected a new auto-refresh change with id greater than $LAST_CHANGE_ID, but it didn't happen"
      exit 1
    fi
    echo "$CHANGE_ID"
}

main() {
    if [ $# -eq 0 ]; then
        show_help
        exit 0
    fi

    local subcommand="$1"
    local action=
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                show_help
                exit 0
                ;;
            *)
                action=$(echo "$subcommand" | tr '-' '_')
                shift
                break
                ;;
        esac
    done

    if [ -z "$(declare -f "$action")" ]; then
        echo "snapd-state: no such command: $subcommand"
        show_help
        exit 1
    fi

    "$action" "$@"
}

main "$@"
